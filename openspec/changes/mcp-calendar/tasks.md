# Tasks: MCP Calendar Integration

## Overview

Extend axios's vdirsyncer calendar infrastructure with declarative Nix configuration and an MCP server for AI-powered calendar management.

---

## Phase 1: Declarative vdirsyncer Configuration

### Task 1.1: Create Calendar Module
- [ ] Create `modules/calendar/default.nix`
- [ ] Register in `modules/default.nix`
- [ ] Add to `lib/default.nix` flaggedModules

```bash
mkdir -p modules/calendar
touch modules/calendar/default.nix
```

### Task 1.2: Define Calendar Options
- [ ] Add `services.calendar.enable` option
- [ ] Add `services.calendar.calendars` attrset option
- [ ] Define submodule for each calendar type (google, caldav, http)

```nix
# modules/calendar/default.nix
{ config, lib, pkgs, ... }:

let
  cfg = config.services.calendar;

  calendarModule = lib.types.submodule {
    options = {
      type = lib.mkOption {
        type = lib.types.enum [ "google" "caldav" "http" ];
        description = "Calendar provider type";
      };

      # Google Calendar options
      tokenFile = lib.mkOption {
        type = lib.types.nullOr lib.types.path;
        default = null;
        description = "Path to OAuth token file (agenix)";
      };

      # CalDAV options
      url = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        description = "CalDAV server URL";
      };

      username = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
      };

      passwordFile = lib.mkOption {
        type = lib.types.nullOr lib.types.path;
        default = null;
      };

      # HTTP subscription options
      icsUrl = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        description = "URL to ICS file (read-only)";
      };

      # Sync behavior
      readWrite = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Enable two-way sync";
      };

      collections = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [ "from b" ];
      };
    };
  };
in
{
  options.services.calendar = {
    enable = lib.mkEnableOption "Calendar sync and management";

    calendars = lib.mkOption {
      type = lib.types.attrsOf calendarModule;
      default = { };
      description = "Calendar sources to sync";
    };

    sync = {
      frequency = lib.mkOption {
        type = lib.types.str;
        default = "5m";
      };

      conflictResolution = lib.mkOption {
        type = lib.types.enum [ "remote" "local" "newer" ];
        default = "remote";
      };
    };

    mcp = {
      enable = lib.mkEnableOption "MCP server for AI calendar access" // {
        default = true;
      };
      writeAccess = lib.mkOption {
        type = lib.types.bool;
        default = true;
      };
    };
  };

  config = lib.mkIf cfg.enable {
    # Phase 1: Just install vdirsyncer
    environment.systemPackages = [ pkgs.vdirsyncer ];
  };
}
```

### Task 1.3: Generate vdirsyncer Config
- [ ] Create home-manager module `home/calendar/config.nix`
- [ ] Generate `~/.config/vdirsyncer/config` from Nix options
- [ ] Support all calendar types (google, caldav, http)

```nix
# home/calendar/config.nix
{ config, lib, osConfig, ... }:

let
  calCfg = osConfig.services.calendar or { };
  calendars = calCfg.calendars or { };

  # Generate vdirsyncer config text
  generateConfig = calendars: ''
    # Auto-generated by axiOS - do not edit manually

    [general]
    status_path = "~/.local/share/vdirsyncer/status/"

    ${lib.concatStringsSep "\n\n" (lib.mapAttrsToList generateCalendar calendars)}
  '';

  generateCalendar = name: cal: ''
    [pair ${name}]
    a = "${name}_local"
    b = "${name}_remote"
    collections = ${builtins.toJSON cal.collections}
    conflict_resolution = "${if cal.readWrite then "newer wins" else "b wins"}"

    [storage ${name}_local]
    type = "filesystem"
    path = "~/.local/share/calendars/${name}/"
    fileext = ".ics"

    ${generateRemoteStorage name cal}
  '';

  generateRemoteStorage = name: cal:
    if cal.type == "google" then ''
      [storage ${name}_remote]
      type = "google_calendar"
      token_file = "${cal.tokenFile}"
    ''
    else if cal.type == "caldav" then ''
      [storage ${name}_remote]
      type = "caldav"
      url = "${cal.url}"
      username = "${cal.username}"
      password.fetch = ["command", "cat", "${cal.passwordFile}"]
    ''
    else if cal.type == "http" then ''
      [storage ${name}_remote]
      type = "http"
      url = "${cal.icsUrl}"
    ''
    else throw "Unknown calendar type: ${cal.type}";
in
{
  config = lib.mkIf (calCfg.enable or false) {
    home.file.".config/vdirsyncer/config".text = generateConfig calendars;

    # Create calendar directories
    home.file.".local/share/calendars/.keep".text = "";
  };
}
```

### Task 1.4: Migrate Existing systemd Timers
- [ ] Move timers from `home/calendar/default.nix` to new module
- [ ] Use configured sync frequency
- [ ] Ensure backward compatibility

---

## Phase 2: Two-Way Sync

### Task 2.1: Update Config Generation
- [ ] When `readWrite = true`, set `conflict_resolution = "newer wins"`
- [ ] Ensure local storage supports writes

### Task 2.2: Test Two-Way Sync
- [ ] Test with Google Calendar
- [ ] Test with CalDAV (Fastmail, Nextcloud)
- [ ] Verify conflicts resolve correctly

### Task 2.3: Add Sync Trigger
- [ ] Add `vdirsyncer sync` trigger after MCP writes
- [ ] Or document manual sync requirement

---

## Phase 3: MCP Calendar Server

### Task 3.1: Create Package Structure
- [ ] Create `pkgs/mcp-calendar/` directory
- [ ] Create `default.nix` with dependencies
- [ ] Create `src/` directory for implementation

```bash
mkdir -p pkgs/mcp-calendar/src
touch pkgs/mcp-calendar/default.nix
```

### Task 3.2: Implement MCP Server
- [ ] Create `src/main.py` - MCP server entry point
- [ ] Create `src/local.py` - Read from local ics files
- [ ] Create `src/caldav.py` - CalDAV operations for writes
- [ ] Create `src/tools.py` - MCP tool definitions

```python
# src/main.py
import asyncio
from mcp.server import Server
from mcp.server.stdio import stdio_server
from .tools import register_tools

app = Server("mcp-calendar")
register_tools(app)

async def main():
    async with stdio_server() as (read_stream, write_stream):
        await app.run(read_stream, write_stream)

if __name__ == "__main__":
    asyncio.run(main())
```

### Task 3.3: Implement Tools

#### list_events
- [ ] Read from local ics files using icalendar library
- [ ] Support date range filtering
- [ ] Support calendar filtering
- [ ] Return structured event data

#### search_events
- [ ] Search event summaries and descriptions
- [ ] Case-insensitive matching
- [ ] Support regex (optional)

#### get_free_busy
- [ ] Aggregate events across calendars
- [ ] Return time slots with availability

#### create_event
- [ ] Validate calendar has `readWrite = true`
- [ ] Generate valid ics file
- [ ] Write to local storage
- [ ] Trigger vdirsyncer sync

#### update_event
- [ ] Find event by ID
- [ ] Modify ics file
- [ ] Preserve unchanged fields

#### delete_event
- [ ] Remove ics file
- [ ] Trigger sync

### Task 3.4: Package for Nix
- [ ] Write `default.nix` with Python dependencies
- [ ] Include: icalendar, caldav, mcp
- [ ] Test package builds

```nix
# pkgs/mcp-calendar/default.nix
{ pkgs, ... }:

pkgs.python3Packages.buildPythonApplication {
  pname = "mcp-calendar";
  version = "0.1.0";

  src = ./src;

  propagatedBuildInputs = with pkgs.python3Packages; [
    mcp
    icalendar
    caldav
    python-dateutil
  ];

  meta = {
    description = "MCP server for calendar management";
    license = pkgs.lib.licenses.mit;
  };
}
```

---

## Phase 4: AI Module Integration

### Task 4.1: Add to MCP Servers
- [ ] Add calendar server to `home/ai/mcp.nix`
- [ ] Conditional on `services.calendar.mcp.enable`

```nix
# In home/ai/mcp.nix
settings.servers.calendar = lib.mkIf (osConfig.services.calendar.mcp.enable or false) {
  command = "${pkgs.mcp-calendar}/bin/mcp-calendar";
  args = [
    "--calendars-dir" "${config.home.homeDirectory}/.local/share/calendars"
    "--config" "${config.home.homeDirectory}/.config/vdirsyncer/config"
  ];
};
```

### Task 4.2: Update System Prompt
- [ ] Add calendar tools to axios system prompt
- [ ] Document available operations

---

## Phase 5: Documentation

### Task 5.1: Create Calendar Spec
- [ ] Update `openspec/specs/pim/spec.md` calendar section
- [ ] Or create dedicated `openspec/specs/calendar/spec.md`

### Task 5.2: Update Module Reference
- [ ] Add calendar module to `docs/MODULE_REFERENCE.md`
- [ ] Include configuration examples

### Task 5.3: Update CLAUDE.md
- [ ] Add calendar to MCP server list
- [ ] Document calendar tools

---

## Phase 6: Testing

### Task 6.1: Phase 1 Tests (Declarative Config)
- [ ] Test: vdirsyncer config generated correctly
- [ ] Test: Google Calendar config format
- [ ] Test: CalDAV config format
- [ ] Test: HTTP subscription config format
- [ ] Test: systemd timers work

### Task 6.2: Phase 2 Tests (Two-Way Sync)
- [ ] Test: Events created locally sync to remote
- [ ] Test: Conflict resolution works
- [ ] Test: Read-only calendars reject writes

### Task 6.3: Phase 3 Tests (MCP Server)
- [ ] Test: list_events returns correct data
- [ ] Test: search_events filters properly
- [ ] Test: create_event creates valid ics
- [ ] Test: update_event modifies existing
- [ ] Test: delete_event removes event
- [ ] Test: MCP server appears in mcp-cli

### Task 6.4: Phase 4 Tests (Integration)
- [ ] Test: Claude Code can list events
- [ ] Test: Claude Code can create events
- [ ] Test: Gemini CLI can use calendar tools

---

## Phase 7: Finalization

### Task 7.1: Code Review
- [ ] Options follow axios patterns
- [ ] agenix integration for secrets
- [ ] MCP server follows MCP spec
- [ ] Error handling comprehensive

### Task 7.2: Merge Specs
- [ ] Move specs to `openspec/specs/`
- [ ] Archive change directory

---

## Files to Create

| File | Purpose |
|------|---------|
| `modules/calendar/default.nix` | NixOS module |
| `home/calendar/config.nix` | vdirsyncer config generation |
| `pkgs/mcp-calendar/default.nix` | MCP server package |
| `pkgs/mcp-calendar/src/main.py` | Server entry point |
| `pkgs/mcp-calendar/src/local.py` | Local ics operations |
| `pkgs/mcp-calendar/src/caldav.py` | CalDAV operations |
| `pkgs/mcp-calendar/src/tools.py` | MCP tool definitions |

## Files to Modify

| File | Changes |
|------|---------|
| `modules/default.nix` | Register calendar module |
| `lib/default.nix` | Add to flaggedModules |
| `home/ai/mcp.nix` | Add calendar MCP server |
| `home/calendar/default.nix` | Refactor to use new module |
| `openspec/specs/pim/spec.md` | Update calendar section |

---

## Estimated Effort

| Phase | Effort |
|-------|--------|
| Phase 1: Declarative Config | 4 hours |
| Phase 2: Two-Way Sync | 2 hours |
| Phase 3: MCP Server | 8 hours |
| Phase 4: AI Integration | 1 hour |
| Phase 5: Documentation | 2 hours |
| Phase 6: Testing | 4 hours |
| Phase 7: Finalization | 1 hour |
| **Total** | **~22 hours** |

---

## Open Questions

1. **Google OAuth flow**: How do users initially authenticate? Document manual `vdirsyncer discover` step?

2. **Sync timing**: Should MCP writes trigger immediate sync, or wait for next timer?

3. **Event IDs**: How to generate stable IDs for events? Use UID from ics file?

4. **Recurring events**: How to handle recurring event modifications?
